package com.fascinito.pos.service;

import com.fascinito.pos.dto.dashboard.*;
import com.fascinito.pos.entity.Order;
import com.fascinito.pos.entity.OrderItem;
import com.fascinito.pos.entity.Product;
import com.fascinito.pos.entity.Role;
import com.fascinito.pos.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.TextStyle;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class DashboardService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final VendorRepository vendorRepository;
    private final LocationRepository locationRepository;
    private final OrderRepository orderRepository;
    private final UserRepository userRepository;

    @Transactional(readOnly = true)
    public DashboardStatsResponse getDashboardStats() {
        log.debug("Fetching dashboard statistics");

        DashboardStatsResponse stats = new DashboardStatsResponse();
        
        // Count basic entities
        stats.setTotalProducts(productRepository.count());
        stats.setTotalCategories(categoryRepository.count());
        stats.setTotalVendors(vendorRepository.count());
        stats.setTotalLocations(locationRepository.count());
        stats.setTotalOrders(orderRepository.count());
        
        // Count customers (users with ROLE_CUSTOMER)
        long customerCount = userRepository.findAll().stream()
                .filter(user -> user.getRoles().stream()
                        .anyMatch(role -> role.getName() == Role.RoleType.ROLE_CUSTOMER))
                .count();
        stats.setTotalCustomers(customerCount);
        
        /**
         * REVENUE & PROFIT CALCULATION:
         * 
         * 1. TOTAL REVENUE: Sum of all order.totalAmount from completed orders
         *    - This is the total money received from customers
         *    - Includes product price + taxes + shipping - discounts
         * 
         * 2. TOTAL PROFIT: Calculated dynamically based on actual product costs
         *    - profit = revenue - cost of goods sold (COGS)
         *    - COGS calculated from product.costPerItem * quantity
         *    - If costPerItem not available, estimates with default 20% margin
         * 
         * 3. TOTAL SPENDING (COGS): Actual cost to acquire/produce goods
         *    - Calculated from product costs in order items
         */
        var orders = orderRepository.findAll();
        double totalRevenue = orders.stream()
                .mapToDouble(order -> order.getTotalAmount().doubleValue())
                .sum();
        
        // Calculate actual profit from order items
        double totalCost = 0.0;
        for (Order order : orders) {
            for (OrderItem item : order.getItems()) {
                Product product = item.getProduct();
                int quantity = item.getQuantity();
                
                if (product.getCostPerItem() != null) {
                    // Use actual product cost
                    totalCost += product.getCostPerItem().multiply(BigDecimal.valueOf(quantity)).doubleValue();
                } else {
                    // Fallback: estimate cost as 80% of item revenue (20% profit margin)
                    double itemRevenue = item.getTotalPrice().doubleValue();
                    totalCost += itemRevenue * 0.80;
                }
            }
        }
        
        double totalProfit = totalRevenue - totalCost;
        double totalSpending = totalCost;
        
        stats.setTotalRevenue(totalRevenue);
        stats.setTotalProfit(totalProfit);
        stats.setTotalSpending(totalSpending);
        
        log.debug("Dashboard stats: {}", stats);
        return stats;
    }

    @Transactional(readOnly = true)
    public List<LocationAnalyticsDTO> getLocationAnalytics() {
        log.debug("Fetching location analytics");
        
        List<LocationAnalyticsDTO> locationAnalytics = new ArrayList<>();
        List<Product> allProducts = productRepository.findAll();
        
        // Group products by location
        Map<String, List<Product>> productsByLocation = allProducts.stream()
                .filter(product -> product.getLocation() != null)
                .collect(Collectors.groupingBy(product -> product.getLocation().getName()));
        
        /**
         * LOCATION-BASED ANALYTICS CALCULATION:
         * 
         * For each location, we calculate:
         * 1. REVENUE: Sum of orderItem.totalPrice for all products in that location
         *    - This is the total sales generated by products at this location
         * 
         * 2. COST (Spending): Cost of goods sold for this location
         *    - If product.costPerItem exists: cost = costPerItem * quantity
         *    - If not available: estimated as 80% of revenue
         * 
         * 3. PROFIT: Revenue - Cost
         *    - This shows the profitability of each location
         */
        for (Map.Entry<String, List<Product>> entry : productsByLocation.entrySet()) {
            String locationName = entry.getKey();
            List<Product> products = entry.getValue();
            
            // Get all order items for products in this location
            double locationRevenue = 0.0;
            double locationCost = 0.0;
            
            for (Product product : products) {
                List<Order> orders = orderRepository.findAll();
                for (Order order : orders) {
                    for (OrderItem item : order.getItems()) {
                        if (item.getProduct().getId().equals(product.getId())) {
                            // Revenue: What customer paid for this item
                            double itemRevenue = item.getTotalPrice().doubleValue();
                            locationRevenue += itemRevenue;
                            
                            // Cost: What it cost us to acquire/produce this item
                            if (product.getCostPerItem() != null) {
                                // Use actual cost if available
                                locationCost += product.getCostPerItem().multiply(BigDecimal.valueOf(item.getQuantity())).doubleValue();
                            } else {
                                // Estimate cost as 80% of revenue if cost not available (20% profit margin)
                                locationCost += itemRevenue * 0.80;
                            }
                        }
                    }
                }
            }
            
            // Profit = Revenue - Cost
            double locationProfit = locationRevenue - locationCost;
            
            LocationAnalyticsDTO dto = new LocationAnalyticsDTO();
            dto.setName(locationName);
            dto.setRevenue(locationRevenue);
            dto.setProfit(locationProfit);
            dto.setSpending(locationCost);
            
            locationAnalytics.add(dto);
        }
        
        // Sort by revenue descending
        locationAnalytics.sort((a, b) -> Double.compare(b.getRevenue(), a.getRevenue()));
        
        log.debug("Location analytics: {}", locationAnalytics);
        return locationAnalytics;
    }

    @Transactional(readOnly = true)
    public List<CategoryDistributionDTO> getCategoryDistribution() {
        log.debug("Fetching category distribution");
        
        List<CategoryDistributionDTO> distribution = new ArrayList<>();
        List<Product> allProducts = productRepository.findAll();
        
        // Group products by category
        Map<String, Long> productsByCategory = allProducts.stream()
                .filter(product -> product.getCategory() != null)
                .collect(Collectors.groupingBy(
                        product -> product.getCategory().getName(),
                        Collectors.counting()
                ));
        
        // Convert to DTO
        for (Map.Entry<String, Long> entry : productsByCategory.entrySet()) {
            CategoryDistributionDTO dto = new CategoryDistributionDTO();
            dto.setName(entry.getKey());
            dto.setValue(entry.getValue());
            distribution.add(dto);
        }
        
        // Sort by value descending
        distribution.sort((a, b) -> Long.compare(b.getValue(), a.getValue()));
        
        // Limit to top 5 and group others
        if (distribution.size() > 5) {
            List<CategoryDistributionDTO> top5 = distribution.subList(0, 5);
            long othersCount = distribution.subList(5, distribution.size()).stream()
                    .mapToLong(CategoryDistributionDTO::getValue)
                    .sum();
            
            if (othersCount > 0) {
                CategoryDistributionDTO others = new CategoryDistributionDTO();
                others.setName("Others");
                others.setValue(othersCount);
                top5.add(others);
            }
            
            distribution = top5;
        }
        
        log.debug("Category distribution: {}", distribution);
        return distribution;
    }

    @Transactional(readOnly = true)
    public List<MonthlyTrendDTO> getMonthlyTrend() {
        log.debug("Fetching monthly trend");
        
        List<MonthlyTrendDTO> trends = new ArrayList<>();
        List<Order> allOrders = orderRepository.findAll();
        
        /**
         * MONTHLY TREND CALCULATION:
         * 
         * Shows revenue and profit trends over the last 6 months
         * 
         * 1. MONTHLY REVENUE: Sum of all order.totalAmount for that month
         *    - Shows sales performance month by month
         * 
         * 2. MONTHLY PROFIT: Currently estimated as 20% of monthly revenue
         *    - In production, should calculate actual profit from order items
         *    - Profit = (Revenue - Cost of all items sold that month)
         * 
         * This helps identify:
         * - Seasonal trends
         * - Growth patterns
         * - Performance improvements or declines
         */
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        
        // Calculate trends for last 6 months
        LocalDateTime currentMonth = LocalDateTime.now();
        for (int i = 5; i >= 0; i--) {
            LocalDateTime month = currentMonth.minusMonths(i);
            String monthName = month.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH);
            
            // Get orders for this specific month and year
            List<Order> monthOrders = allOrders.stream()
                    .filter(order -> order.getCreatedAt().getMonth() == month.getMonth() 
                            && order.getCreatedAt().getYear() == month.getYear())
                    .collect(Collectors.toList());
            
            // Calculate monthly revenue
            double monthRevenue = monthOrders.stream()
                    .mapToDouble(order -> order.getTotalAmount().doubleValue())
                    .sum();
            
            // Calculate actual monthly profit from order items
            double monthCost = 0.0;
            for (Order order : monthOrders) {
                for (OrderItem item : order.getItems()) {
                    Product product = item.getProduct();
                    int quantity = item.getQuantity();
                    
                    if (product.getCostPerItem() != null) {
                        // Use actual product cost
                        monthCost += product.getCostPerItem().multiply(BigDecimal.valueOf(quantity)).doubleValue();
                    } else {
                        // Fallback: estimate cost as 80% of item revenue
                        double itemRevenue = item.getTotalPrice().doubleValue();
                        monthCost += itemRevenue * 0.80;
                    }
                }
            }
            
            double monthProfit = monthRevenue - monthCost;
            
            MonthlyTrendDTO dto = new MonthlyTrendDTO();
            dto.setMonth(monthName);
            dto.setRevenue(monthRevenue);
            dto.setProfit(monthProfit);
            
            trends.add(dto);
        }
        
        log.debug("Monthly trends: {}", trends);
        return trends;
    }
}
